// Code generated by counterfeiter. DO NOT EDIT.
package tffakes

import (
	"context"
	"sync"

	"github.com/cloudfoundry/cloud-service-broker/pkg/providers/tf"
	"github.com/cloudfoundry/cloud-service-broker/pkg/providers/tf/wrapper"
	version "github.com/hashicorp/go-version"
)

type FakeWorkspace struct {
	ApplyStub        func(context.Context, wrapper.TerraformExecutor) error
	applyMutex       sync.RWMutex
	applyArgsForCall []struct {
		arg1 context.Context
		arg2 wrapper.TerraformExecutor
	}
	applyReturns struct {
		result1 error
	}
	applyReturnsOnCall map[int]struct {
		result1 error
	}
	DestroyStub        func(context.Context, wrapper.TerraformExecutor) error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct {
		arg1 context.Context
		arg2 wrapper.TerraformExecutor
	}
	destroyReturns struct {
		result1 error
	}
	destroyReturnsOnCall map[int]struct {
		result1 error
	}
	ImportStub        func(context.Context, wrapper.TerraformExecutor, map[string]string) error
	importMutex       sync.RWMutex
	importArgsForCall []struct {
		arg1 context.Context
		arg2 wrapper.TerraformExecutor
		arg3 map[string]string
	}
	importReturns struct {
		result1 error
	}
	importReturnsOnCall map[int]struct {
		result1 error
	}
	ModuleDefinitionsStub        func() []wrapper.ModuleDefinition
	moduleDefinitionsMutex       sync.RWMutex
	moduleDefinitionsArgsForCall []struct {
	}
	moduleDefinitionsReturns struct {
		result1 []wrapper.ModuleDefinition
	}
	moduleDefinitionsReturnsOnCall map[int]struct {
		result1 []wrapper.ModuleDefinition
	}
	ModuleInstancesStub        func() []wrapper.ModuleInstance
	moduleInstancesMutex       sync.RWMutex
	moduleInstancesArgsForCall []struct {
	}
	moduleInstancesReturns struct {
		result1 []wrapper.ModuleInstance
	}
	moduleInstancesReturnsOnCall map[int]struct {
		result1 []wrapper.ModuleInstance
	}
	OutputsStub        func(string) (map[string]interface{}, error)
	outputsMutex       sync.RWMutex
	outputsArgsForCall []struct {
		arg1 string
	}
	outputsReturns struct {
		result1 map[string]interface{}
		result2 error
	}
	outputsReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 error
	}
	PlanStub        func(context.Context, wrapper.TerraformExecutor) error
	planMutex       sync.RWMutex
	planArgsForCall []struct {
		arg1 context.Context
		arg2 wrapper.TerraformExecutor
	}
	planReturns struct {
		result1 error
	}
	planReturnsOnCall map[int]struct {
		result1 error
	}
	SerializeStub        func() (string, error)
	serializeMutex       sync.RWMutex
	serializeArgsForCall []struct {
	}
	serializeReturns struct {
		result1 string
		result2 error
	}
	serializeReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ShowStub        func(context.Context, wrapper.TerraformExecutor) (string, error)
	showMutex       sync.RWMutex
	showArgsForCall []struct {
		arg1 context.Context
		arg2 wrapper.TerraformExecutor
	}
	showReturns struct {
		result1 string
		result2 error
	}
	showReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	StateVersionStub        func() (*version.Version, error)
	stateVersionMutex       sync.RWMutex
	stateVersionArgsForCall []struct {
	}
	stateVersionReturns struct {
		result1 *version.Version
		result2 error
	}
	stateVersionReturnsOnCall map[int]struct {
		result1 *version.Version
		result2 error
	}
	UpdateInstanceConfigurationStub        func(map[string]interface{}) error
	updateInstanceConfigurationMutex       sync.RWMutex
	updateInstanceConfigurationArgsForCall []struct {
		arg1 map[string]interface{}
	}
	updateInstanceConfigurationReturns struct {
		result1 error
	}
	updateInstanceConfigurationReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateStub        func(context.Context, wrapper.TerraformExecutor) error
	validateMutex       sync.RWMutex
	validateArgsForCall []struct {
		arg1 context.Context
		arg2 wrapper.TerraformExecutor
	}
	validateReturns struct {
		result1 error
	}
	validateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWorkspace) Apply(arg1 context.Context, arg2 wrapper.TerraformExecutor) error {
	fake.applyMutex.Lock()
	ret, specificReturn := fake.applyReturnsOnCall[len(fake.applyArgsForCall)]
	fake.applyArgsForCall = append(fake.applyArgsForCall, struct {
		arg1 context.Context
		arg2 wrapper.TerraformExecutor
	}{arg1, arg2})
	stub := fake.ApplyStub
	fakeReturns := fake.applyReturns
	fake.recordInvocation("Apply", []interface{}{arg1, arg2})
	fake.applyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorkspace) ApplyCallCount() int {
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	return len(fake.applyArgsForCall)
}

func (fake *FakeWorkspace) ApplyCalls(stub func(context.Context, wrapper.TerraformExecutor) error) {
	fake.applyMutex.Lock()
	defer fake.applyMutex.Unlock()
	fake.ApplyStub = stub
}

func (fake *FakeWorkspace) ApplyArgsForCall(i int) (context.Context, wrapper.TerraformExecutor) {
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	argsForCall := fake.applyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkspace) ApplyReturns(result1 error) {
	fake.applyMutex.Lock()
	defer fake.applyMutex.Unlock()
	fake.ApplyStub = nil
	fake.applyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkspace) ApplyReturnsOnCall(i int, result1 error) {
	fake.applyMutex.Lock()
	defer fake.applyMutex.Unlock()
	fake.ApplyStub = nil
	if fake.applyReturnsOnCall == nil {
		fake.applyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.applyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkspace) Destroy(arg1 context.Context, arg2 wrapper.TerraformExecutor) error {
	fake.destroyMutex.Lock()
	ret, specificReturn := fake.destroyReturnsOnCall[len(fake.destroyArgsForCall)]
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct {
		arg1 context.Context
		arg2 wrapper.TerraformExecutor
	}{arg1, arg2})
	stub := fake.DestroyStub
	fakeReturns := fake.destroyReturns
	fake.recordInvocation("Destroy", []interface{}{arg1, arg2})
	fake.destroyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorkspace) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakeWorkspace) DestroyCalls(stub func(context.Context, wrapper.TerraformExecutor) error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = stub
}

func (fake *FakeWorkspace) DestroyArgsForCall(i int) (context.Context, wrapper.TerraformExecutor) {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	argsForCall := fake.destroyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkspace) DestroyReturns(result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkspace) DestroyReturnsOnCall(i int, result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	if fake.destroyReturnsOnCall == nil {
		fake.destroyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkspace) Import(arg1 context.Context, arg2 wrapper.TerraformExecutor, arg3 map[string]string) error {
	fake.importMutex.Lock()
	ret, specificReturn := fake.importReturnsOnCall[len(fake.importArgsForCall)]
	fake.importArgsForCall = append(fake.importArgsForCall, struct {
		arg1 context.Context
		arg2 wrapper.TerraformExecutor
		arg3 map[string]string
	}{arg1, arg2, arg3})
	stub := fake.ImportStub
	fakeReturns := fake.importReturns
	fake.recordInvocation("Import", []interface{}{arg1, arg2, arg3})
	fake.importMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorkspace) ImportCallCount() int {
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	return len(fake.importArgsForCall)
}

func (fake *FakeWorkspace) ImportCalls(stub func(context.Context, wrapper.TerraformExecutor, map[string]string) error) {
	fake.importMutex.Lock()
	defer fake.importMutex.Unlock()
	fake.ImportStub = stub
}

func (fake *FakeWorkspace) ImportArgsForCall(i int) (context.Context, wrapper.TerraformExecutor, map[string]string) {
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	argsForCall := fake.importArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkspace) ImportReturns(result1 error) {
	fake.importMutex.Lock()
	defer fake.importMutex.Unlock()
	fake.ImportStub = nil
	fake.importReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkspace) ImportReturnsOnCall(i int, result1 error) {
	fake.importMutex.Lock()
	defer fake.importMutex.Unlock()
	fake.ImportStub = nil
	if fake.importReturnsOnCall == nil {
		fake.importReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.importReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkspace) ModuleDefinitions() []wrapper.ModuleDefinition {
	fake.moduleDefinitionsMutex.Lock()
	ret, specificReturn := fake.moduleDefinitionsReturnsOnCall[len(fake.moduleDefinitionsArgsForCall)]
	fake.moduleDefinitionsArgsForCall = append(fake.moduleDefinitionsArgsForCall, struct {
	}{})
	stub := fake.ModuleDefinitionsStub
	fakeReturns := fake.moduleDefinitionsReturns
	fake.recordInvocation("ModuleDefinitions", []interface{}{})
	fake.moduleDefinitionsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorkspace) ModuleDefinitionsCallCount() int {
	fake.moduleDefinitionsMutex.RLock()
	defer fake.moduleDefinitionsMutex.RUnlock()
	return len(fake.moduleDefinitionsArgsForCall)
}

func (fake *FakeWorkspace) ModuleDefinitionsCalls(stub func() []wrapper.ModuleDefinition) {
	fake.moduleDefinitionsMutex.Lock()
	defer fake.moduleDefinitionsMutex.Unlock()
	fake.ModuleDefinitionsStub = stub
}

func (fake *FakeWorkspace) ModuleDefinitionsReturns(result1 []wrapper.ModuleDefinition) {
	fake.moduleDefinitionsMutex.Lock()
	defer fake.moduleDefinitionsMutex.Unlock()
	fake.ModuleDefinitionsStub = nil
	fake.moduleDefinitionsReturns = struct {
		result1 []wrapper.ModuleDefinition
	}{result1}
}

func (fake *FakeWorkspace) ModuleDefinitionsReturnsOnCall(i int, result1 []wrapper.ModuleDefinition) {
	fake.moduleDefinitionsMutex.Lock()
	defer fake.moduleDefinitionsMutex.Unlock()
	fake.ModuleDefinitionsStub = nil
	if fake.moduleDefinitionsReturnsOnCall == nil {
		fake.moduleDefinitionsReturnsOnCall = make(map[int]struct {
			result1 []wrapper.ModuleDefinition
		})
	}
	fake.moduleDefinitionsReturnsOnCall[i] = struct {
		result1 []wrapper.ModuleDefinition
	}{result1}
}

func (fake *FakeWorkspace) ModuleInstances() []wrapper.ModuleInstance {
	fake.moduleInstancesMutex.Lock()
	ret, specificReturn := fake.moduleInstancesReturnsOnCall[len(fake.moduleInstancesArgsForCall)]
	fake.moduleInstancesArgsForCall = append(fake.moduleInstancesArgsForCall, struct {
	}{})
	stub := fake.ModuleInstancesStub
	fakeReturns := fake.moduleInstancesReturns
	fake.recordInvocation("ModuleInstances", []interface{}{})
	fake.moduleInstancesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorkspace) ModuleInstancesCallCount() int {
	fake.moduleInstancesMutex.RLock()
	defer fake.moduleInstancesMutex.RUnlock()
	return len(fake.moduleInstancesArgsForCall)
}

func (fake *FakeWorkspace) ModuleInstancesCalls(stub func() []wrapper.ModuleInstance) {
	fake.moduleInstancesMutex.Lock()
	defer fake.moduleInstancesMutex.Unlock()
	fake.ModuleInstancesStub = stub
}

func (fake *FakeWorkspace) ModuleInstancesReturns(result1 []wrapper.ModuleInstance) {
	fake.moduleInstancesMutex.Lock()
	defer fake.moduleInstancesMutex.Unlock()
	fake.ModuleInstancesStub = nil
	fake.moduleInstancesReturns = struct {
		result1 []wrapper.ModuleInstance
	}{result1}
}

func (fake *FakeWorkspace) ModuleInstancesReturnsOnCall(i int, result1 []wrapper.ModuleInstance) {
	fake.moduleInstancesMutex.Lock()
	defer fake.moduleInstancesMutex.Unlock()
	fake.ModuleInstancesStub = nil
	if fake.moduleInstancesReturnsOnCall == nil {
		fake.moduleInstancesReturnsOnCall = make(map[int]struct {
			result1 []wrapper.ModuleInstance
		})
	}
	fake.moduleInstancesReturnsOnCall[i] = struct {
		result1 []wrapper.ModuleInstance
	}{result1}
}

func (fake *FakeWorkspace) Outputs(arg1 string) (map[string]interface{}, error) {
	fake.outputsMutex.Lock()
	ret, specificReturn := fake.outputsReturnsOnCall[len(fake.outputsArgsForCall)]
	fake.outputsArgsForCall = append(fake.outputsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.OutputsStub
	fakeReturns := fake.outputsReturns
	fake.recordInvocation("Outputs", []interface{}{arg1})
	fake.outputsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkspace) OutputsCallCount() int {
	fake.outputsMutex.RLock()
	defer fake.outputsMutex.RUnlock()
	return len(fake.outputsArgsForCall)
}

func (fake *FakeWorkspace) OutputsCalls(stub func(string) (map[string]interface{}, error)) {
	fake.outputsMutex.Lock()
	defer fake.outputsMutex.Unlock()
	fake.OutputsStub = stub
}

func (fake *FakeWorkspace) OutputsArgsForCall(i int) string {
	fake.outputsMutex.RLock()
	defer fake.outputsMutex.RUnlock()
	argsForCall := fake.outputsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkspace) OutputsReturns(result1 map[string]interface{}, result2 error) {
	fake.outputsMutex.Lock()
	defer fake.outputsMutex.Unlock()
	fake.OutputsStub = nil
	fake.outputsReturns = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkspace) OutputsReturnsOnCall(i int, result1 map[string]interface{}, result2 error) {
	fake.outputsMutex.Lock()
	defer fake.outputsMutex.Unlock()
	fake.OutputsStub = nil
	if fake.outputsReturnsOnCall == nil {
		fake.outputsReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 error
		})
	}
	fake.outputsReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkspace) Plan(arg1 context.Context, arg2 wrapper.TerraformExecutor) error {
	fake.planMutex.Lock()
	ret, specificReturn := fake.planReturnsOnCall[len(fake.planArgsForCall)]
	fake.planArgsForCall = append(fake.planArgsForCall, struct {
		arg1 context.Context
		arg2 wrapper.TerraformExecutor
	}{arg1, arg2})
	stub := fake.PlanStub
	fakeReturns := fake.planReturns
	fake.recordInvocation("Plan", []interface{}{arg1, arg2})
	fake.planMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorkspace) PlanCallCount() int {
	fake.planMutex.RLock()
	defer fake.planMutex.RUnlock()
	return len(fake.planArgsForCall)
}

func (fake *FakeWorkspace) PlanCalls(stub func(context.Context, wrapper.TerraformExecutor) error) {
	fake.planMutex.Lock()
	defer fake.planMutex.Unlock()
	fake.PlanStub = stub
}

func (fake *FakeWorkspace) PlanArgsForCall(i int) (context.Context, wrapper.TerraformExecutor) {
	fake.planMutex.RLock()
	defer fake.planMutex.RUnlock()
	argsForCall := fake.planArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkspace) PlanReturns(result1 error) {
	fake.planMutex.Lock()
	defer fake.planMutex.Unlock()
	fake.PlanStub = nil
	fake.planReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkspace) PlanReturnsOnCall(i int, result1 error) {
	fake.planMutex.Lock()
	defer fake.planMutex.Unlock()
	fake.PlanStub = nil
	if fake.planReturnsOnCall == nil {
		fake.planReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.planReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkspace) Serialize() (string, error) {
	fake.serializeMutex.Lock()
	ret, specificReturn := fake.serializeReturnsOnCall[len(fake.serializeArgsForCall)]
	fake.serializeArgsForCall = append(fake.serializeArgsForCall, struct {
	}{})
	stub := fake.SerializeStub
	fakeReturns := fake.serializeReturns
	fake.recordInvocation("Serialize", []interface{}{})
	fake.serializeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkspace) SerializeCallCount() int {
	fake.serializeMutex.RLock()
	defer fake.serializeMutex.RUnlock()
	return len(fake.serializeArgsForCall)
}

func (fake *FakeWorkspace) SerializeCalls(stub func() (string, error)) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = stub
}

func (fake *FakeWorkspace) SerializeReturns(result1 string, result2 error) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = nil
	fake.serializeReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkspace) SerializeReturnsOnCall(i int, result1 string, result2 error) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = nil
	if fake.serializeReturnsOnCall == nil {
		fake.serializeReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.serializeReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkspace) Show(arg1 context.Context, arg2 wrapper.TerraformExecutor) (string, error) {
	fake.showMutex.Lock()
	ret, specificReturn := fake.showReturnsOnCall[len(fake.showArgsForCall)]
	fake.showArgsForCall = append(fake.showArgsForCall, struct {
		arg1 context.Context
		arg2 wrapper.TerraformExecutor
	}{arg1, arg2})
	stub := fake.ShowStub
	fakeReturns := fake.showReturns
	fake.recordInvocation("Show", []interface{}{arg1, arg2})
	fake.showMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkspace) ShowCallCount() int {
	fake.showMutex.RLock()
	defer fake.showMutex.RUnlock()
	return len(fake.showArgsForCall)
}

func (fake *FakeWorkspace) ShowCalls(stub func(context.Context, wrapper.TerraformExecutor) (string, error)) {
	fake.showMutex.Lock()
	defer fake.showMutex.Unlock()
	fake.ShowStub = stub
}

func (fake *FakeWorkspace) ShowArgsForCall(i int) (context.Context, wrapper.TerraformExecutor) {
	fake.showMutex.RLock()
	defer fake.showMutex.RUnlock()
	argsForCall := fake.showArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkspace) ShowReturns(result1 string, result2 error) {
	fake.showMutex.Lock()
	defer fake.showMutex.Unlock()
	fake.ShowStub = nil
	fake.showReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkspace) ShowReturnsOnCall(i int, result1 string, result2 error) {
	fake.showMutex.Lock()
	defer fake.showMutex.Unlock()
	fake.ShowStub = nil
	if fake.showReturnsOnCall == nil {
		fake.showReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.showReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkspace) StateVersion() (*version.Version, error) {
	fake.stateVersionMutex.Lock()
	ret, specificReturn := fake.stateVersionReturnsOnCall[len(fake.stateVersionArgsForCall)]
	fake.stateVersionArgsForCall = append(fake.stateVersionArgsForCall, struct {
	}{})
	stub := fake.StateVersionStub
	fakeReturns := fake.stateVersionReturns
	fake.recordInvocation("StateVersion", []interface{}{})
	fake.stateVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkspace) StateVersionCallCount() int {
	fake.stateVersionMutex.RLock()
	defer fake.stateVersionMutex.RUnlock()
	return len(fake.stateVersionArgsForCall)
}

func (fake *FakeWorkspace) StateVersionCalls(stub func() (*version.Version, error)) {
	fake.stateVersionMutex.Lock()
	defer fake.stateVersionMutex.Unlock()
	fake.StateVersionStub = stub
}

func (fake *FakeWorkspace) StateVersionReturns(result1 *version.Version, result2 error) {
	fake.stateVersionMutex.Lock()
	defer fake.stateVersionMutex.Unlock()
	fake.StateVersionStub = nil
	fake.stateVersionReturns = struct {
		result1 *version.Version
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkspace) StateVersionReturnsOnCall(i int, result1 *version.Version, result2 error) {
	fake.stateVersionMutex.Lock()
	defer fake.stateVersionMutex.Unlock()
	fake.StateVersionStub = nil
	if fake.stateVersionReturnsOnCall == nil {
		fake.stateVersionReturnsOnCall = make(map[int]struct {
			result1 *version.Version
			result2 error
		})
	}
	fake.stateVersionReturnsOnCall[i] = struct {
		result1 *version.Version
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkspace) UpdateInstanceConfiguration(arg1 map[string]interface{}) error {
	fake.updateInstanceConfigurationMutex.Lock()
	ret, specificReturn := fake.updateInstanceConfigurationReturnsOnCall[len(fake.updateInstanceConfigurationArgsForCall)]
	fake.updateInstanceConfigurationArgsForCall = append(fake.updateInstanceConfigurationArgsForCall, struct {
		arg1 map[string]interface{}
	}{arg1})
	stub := fake.UpdateInstanceConfigurationStub
	fakeReturns := fake.updateInstanceConfigurationReturns
	fake.recordInvocation("UpdateInstanceConfiguration", []interface{}{arg1})
	fake.updateInstanceConfigurationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorkspace) UpdateInstanceConfigurationCallCount() int {
	fake.updateInstanceConfigurationMutex.RLock()
	defer fake.updateInstanceConfigurationMutex.RUnlock()
	return len(fake.updateInstanceConfigurationArgsForCall)
}

func (fake *FakeWorkspace) UpdateInstanceConfigurationCalls(stub func(map[string]interface{}) error) {
	fake.updateInstanceConfigurationMutex.Lock()
	defer fake.updateInstanceConfigurationMutex.Unlock()
	fake.UpdateInstanceConfigurationStub = stub
}

func (fake *FakeWorkspace) UpdateInstanceConfigurationArgsForCall(i int) map[string]interface{} {
	fake.updateInstanceConfigurationMutex.RLock()
	defer fake.updateInstanceConfigurationMutex.RUnlock()
	argsForCall := fake.updateInstanceConfigurationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkspace) UpdateInstanceConfigurationReturns(result1 error) {
	fake.updateInstanceConfigurationMutex.Lock()
	defer fake.updateInstanceConfigurationMutex.Unlock()
	fake.UpdateInstanceConfigurationStub = nil
	fake.updateInstanceConfigurationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkspace) UpdateInstanceConfigurationReturnsOnCall(i int, result1 error) {
	fake.updateInstanceConfigurationMutex.Lock()
	defer fake.updateInstanceConfigurationMutex.Unlock()
	fake.UpdateInstanceConfigurationStub = nil
	if fake.updateInstanceConfigurationReturnsOnCall == nil {
		fake.updateInstanceConfigurationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateInstanceConfigurationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkspace) Validate(arg1 context.Context, arg2 wrapper.TerraformExecutor) error {
	fake.validateMutex.Lock()
	ret, specificReturn := fake.validateReturnsOnCall[len(fake.validateArgsForCall)]
	fake.validateArgsForCall = append(fake.validateArgsForCall, struct {
		arg1 context.Context
		arg2 wrapper.TerraformExecutor
	}{arg1, arg2})
	stub := fake.ValidateStub
	fakeReturns := fake.validateReturns
	fake.recordInvocation("Validate", []interface{}{arg1, arg2})
	fake.validateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorkspace) ValidateCallCount() int {
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	return len(fake.validateArgsForCall)
}

func (fake *FakeWorkspace) ValidateCalls(stub func(context.Context, wrapper.TerraformExecutor) error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = stub
}

func (fake *FakeWorkspace) ValidateArgsForCall(i int) (context.Context, wrapper.TerraformExecutor) {
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	argsForCall := fake.validateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkspace) ValidateReturns(result1 error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	fake.validateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkspace) ValidateReturnsOnCall(i int, result1 error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	if fake.validateReturnsOnCall == nil {
		fake.validateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkspace) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	fake.moduleDefinitionsMutex.RLock()
	defer fake.moduleDefinitionsMutex.RUnlock()
	fake.moduleInstancesMutex.RLock()
	defer fake.moduleInstancesMutex.RUnlock()
	fake.outputsMutex.RLock()
	defer fake.outputsMutex.RUnlock()
	fake.planMutex.RLock()
	defer fake.planMutex.RUnlock()
	fake.serializeMutex.RLock()
	defer fake.serializeMutex.RUnlock()
	fake.showMutex.RLock()
	defer fake.showMutex.RUnlock()
	fake.stateVersionMutex.RLock()
	defer fake.stateVersionMutex.RUnlock()
	fake.updateInstanceConfigurationMutex.RLock()
	defer fake.updateInstanceConfigurationMutex.RUnlock()
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWorkspace) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ tf.Workspace = new(FakeWorkspace)
