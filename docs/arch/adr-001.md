# Encryption of sensitive data
## Context

CSB receives, stores, and passes credentials to OpenTofu. For example, IaaS credentials,
database server credentials, binding account details, etc.
 
The credentials can be passed into CSB in three different ways:
 - Environment variables
 - As parameters to a broker api request (e.g a cf create-service with a -c flag with options)
 - As a result (output) of a OpenTofu operation (e.g. admin password for a newly provisioned database, binding credentials, etc.)

All these credentials are currently stored in the CSB database in plain text.

Most CSB tables contain credentials of some type:

* Table `service_instance_details` in field `other_details`.
    This field contains json including IaaS credentials, admin credentials for provisioned resources generated by OpenTofu, and any other custom credential that the service offering defines in its yml file.
* Table `provision_request_details` in field `request_details`.
    This field contains json including all credentials passed in the provision request (-c flag). IaaS credentials, admin credentials for servers where we want resources to be created and any other custom credential that the service offering defines in its yml file.
* Table `service_binding_credentials` in field `other_details`.
    This field contains json including all credentials passed in the binding request and the OpenTofu outputs generated during binding. IaaS credentials, admin credentials for servers where we want resources to be created and any other custom credential that the service offering defines in its yml file.
* Table `terraform_deployments` in field `workspace`.
    This field contains the terraform/OpenTofu workspace including the state file.
    The state has all variables replaced, meaning that all credentials reside there in plain text.

> Note: OpenTofu replaced Terraform in the CSB starting with version 1.0.0.
> There may still be some references to Terraform in the codebase and database structure.
 
We are addressing the need to encrypt this data.

## Key or password

Symmetric encryption algorithms require a key. Many programs require a user to have a password
which gets converted to a key. We considered whether to ask the user to supply a key or a password.

1. Asking for a key is simpler to implement, but requires the user to understand how to generate
a good key. In interviews, we found that there was generally good understanding about passwords and
how to make passwords secure. But there much less understanding about keys. We were concerned
that users would confuse keys with 32 byte passwords. An important difference between a key and a
password is that a key should have 8 bits of entropy per byte, whereas a password typically
has 6 bits of entropy per byte because only alphanumeric and other printable characters are used.
This might result in many systems being unknowingly configured with weak keys.

1. Passwords are easier for users to reason about as they are ubiquitous. They can be
converted into keys using an algorithm such as PDKDF2, but it's necessary to add
additional salt. This salt has to be generated and then stored with an association
to the password, so that the same password results in the
same cryptographic key being computed. An example to follow would be the Cloud Controller
which has a database table which associates password labels with salt.

We decided to opt for passwords because it's the approach used by CredHub and Cloud Controller,
so it's an approach that is well understood by users, and harder to accidentally
configure insecurely.

## Password Management and Rotation

Ways to set the password:
1. Some users deploy CSB as Tile via Ops Manager. These users expect passwords to be
managed in Ops Manager, similarly to the Cloud Controller and CredHub.
1. Some users deploy CSB as an app. These users will set a password using the `cf set-env`
command, so that the password is visible to the app as an environment variable.

Similarly to Cloud Controller and CredHub, CSB will take a collection of passwords.
This will manifest as a JSON array containing JSON objects.
Each password must have:
- The password
- A unique label to identify the password. Labels are stored in the CSB database
but passwords are never stored.
- A flag to identify a password as Primary. Only one password may be primary.

Password rotation was identified as a core requirement. We opted to use the same method
as Cloud Controller and CredHub.
For the first deployment, if a primary password is set then in is used to encrypt the data.
If no primary password is set then the data is not encrypted.
When a users wishes to change the password, add a password, or remove encryption, they:

1. Add a new primary password to the collection of passwords. The previous primary should
no longer be marked primary. If there are no primary password then encryption is disabled.
1. Restart the CSB app (potentially via Apply Changes in Ops Manager) so that the app can
read the data with the old password and write it with the new password. The app will detect
a new password and immediately re-encrypt the whole database.
1. Once the app has migrated all the data, the old password no longer needed to be specified.

In order to avoid users mistakenly setting a non-primary password and assuming that encryption
has been enabled, we will add a boolean configuration flag that specified whether
database encryption should be enabled. If it is enabled and there is no primary password then
the CSB will fail to start. Equally, if it is disabled, and a primary password is specified then
the CSB will fail to start. This protects against accidental misconfiguration.

## Security

The purpose of encrypting the database is to render the sensitive fields unreadable to anyone
who illicitly obtains a copy of the database. We assume that users strive to keep the database
secret, but from time to time an attacker manages to access a live or backup database.

The AES256-GCM algorithm is currently considered to be secure. But an attacker might attempt to
avoid a brute-force attack on the algorithm by attempting to guess the password. This is
because in practice most passwords contain much less entropy than 256 bit keys, so they are
easier to brute-force.
- We have chosen to make the minimum password length 20 characters. This is the same as
CredHub. Users are free to use much longer passwords, which are typically more secure.
- There is a 32bit salt associated with each password label, and the salt is stored in
the database alongside the label.
- We use PBKDF2 with SHA256 and 100000 iterations to generate a key from the password and salt.
This is a deliberately slow algorithm that makes it expensive to brute-force the password.
100000 iterations is the highest value that we could choose without the CSB app being
noticeably slow to start.

## Code structure

There was already a precedent for using accessor methods on model objects to do JSON encoding/decoding.
One option was to enchance these accessors to do encryption/decryption as well.

The GORM package that is used access the database allows for custom types that implement
the Scanner and Valuer interfaces which can transparently transform data as it is saved or
loaded from the database. This can be used to JSON encode/decode data, or to encrypt/decrypt it.

We decided to enhance the accessor methods rather than implement Scanner/Valuer because:
- It follows a precedent
- It makes clear when and where credentials are being handled in plain text, as opposed of a custom datatype that would only be made visible in the model definition as an annotation.
- Decryption can be left out until credentials are actually needed and will be perform as soon as they are set, limiting the possibilities of leaking them with logging, under bad error handling etc. If we were to use the custom data type approach, encryption would happen as soon as we read from the database and delayed until we actually write to the database.

At some future point we may refactor the accessor methods to implement
Scanner/Valuer and make the data transformation transparent.

# Status

DRAFT

# Consequences

If a user forgets their password then the data is unrecoverable.

Troubleshooting becomes more challenging as all the parameters used are going to be
encrypted in the database.


 

